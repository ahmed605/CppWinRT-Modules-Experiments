# 03-SimpleCustomComponent Notes

This is where things really break down.

This project should build a custom WinRT component for re-use in other projects. You can see how this works just fine for the pch variant of this project, as well as for the pch variant of the `04-CustomConsoleApp`.

As a project consuming the winrt module, this seemingly doesn't work at all. I'm guessing that the auto-generated cppwinrt files for custom components don't work with modules at all.


Where do you put the `import winrt;` in a component like this?
* In the `.cpp`?
  - Above the `#include "Class.h"; #include "Class.g.cpp"`?
    - You'll get 100 errors about various different windows.numerics types being redefined.
  - Below the `#include "Class.h"; #include "Class.g.cpp"`?
    - You'll get a single error about
      ```
      2>    ...\00-WinRTModule\winrt\base.h(538,48): error C2374: 'winrt::take_ownership_from_abi': redefinition; multiple initialization
      2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\base.h(538): message : see declaration of 'winrt::take_ownership_from_abi'
      2>    ...\00-WinRTModule\winrt\Windows.Foundation.h(663): message : see reference to function template instantiation 'auto winrt::impl::consume_Windows_Foundation_IUriRuntimeClass<winrt::Windows::Foundation::IUriRuntimeClass>::Domain(void) const' being compiled
      2>    The command exited with code 2.
      ```
    -
* In the `.h`?
  - Above the `#include "Class.g.h"`?
    - Same numerics errors as before
  - Below the `#include "Class.g.h"`?
    - same `winrt::take_ownership_from_abi` redefinition as before.
* The autogenerated `module.g.cpp` automatically includes `winrt/base.h`, which of course, isn't the module version.
* The autogenerated `winrt\SimpleCustomComponent.h` file _also_ includes `winrt/base.h`.
* If you manually remove the `base.h` references in those files, then you'll get
  ```
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(13,32): error C3856: 'category': symbol is not a class template
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(13,31): error C2143: syntax error: missing ';' before 'winrt::SimpleCustomComponent::IClass'
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(13,14): error C2913: explicit specialization; 'winrt::impl::category' is not a specialization of a class template
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(13,37): error C2059: syntax error: '>'
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(13,38): error C2143: syntax error: missing ';' before '{'
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(13,38): error C2447: '{': missing function header (old-style formal list?)
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(14,101): error C2913: explicit specialization; 'winrt::impl::category' is not a specialization of a class template
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(15,40): error C7568: argument list missing after assumed function template 'name_v'
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(15): error C2062: type 'unknown-type' unexpected
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(16,40): error C7568: argument list missing after assumed function template 'name_v'
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(16): error C2062: type 'unknown-type' unexpected
  2>    ...\03-SimpleCustomComponent\mod\x64\Debug\Generated Files\winrt\impl\SimpleCustomComponent.0.h(17,1): fatal error C1903: unable to recover from previous error(s); stopping compilation
  2>    INTERNAL COMPILER ERROR in 'C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.31.30818\bin\HostX64\x64\CL.exe'
  ```
  - Yes this is a compiler error, but this also probably isn't the right solution.


* How should this work?
  - Should the consuming component `#include winrt/base.h` always?
    - Presumably no, the module import should be good enough.
  - Assuming the above answer is no, how do we adjust the winrt codegen that the generated `module.g.cpp` (and projected header) will work?


* You know, the compiler error might be part of this, but also, I don't think the cppwinrt generated code should work. The code in question is

  ```c++
  #pragma once
  #ifndef WINRT_SimpleCustomComponent_0_H
  #define WINRT_SimpleCustomComponent_0_H
  WINRT_EXPORT namespace winrt::SimpleCustomComponent
  {
      struct IClass;
      struct Class;
  }
  namespace winrt::impl
  {
      template <> struct category<winrt::SimpleCustomComponent::IClass>{ using type = interface_category; };
      ...
  ```
  This `category` type is defined in `base.h`, in the `winrt::impl` namespace, which straight up isn't exported. Even if you go through and manually export the winrt::impl bits for `category`, `name_v`, `guid_v` and `default_interface`, then you'll still eventually run into that compiler error.

  It doesn't make sense to export the `winrt::impl` bits, obviously, since those should only be used by types inside the winrt implementation itself.

  So, that gets us to
* A component that's authoring a winrt type should still `#include winrt/base.h`, even if they're using modules.
* If you manually suppress the numerics header,
  - then `import winrt` in the header before `Class.g.h`, then you'll still get a redefinition for basically everything in the `winrt` namespace, from the `base.h` included via the projection's header.
  -
* Changing `take_owner...` to
  `constexpr take_ownership_from_abi_t take_ownership_from_abi{};`
  did not fix it

* Includes need to be before imports.
* `Class.g.h` includes `SimpleCustomComponent.h` (projection), which includes `base.h`, and both the `g.h` and projection _need_ winrt::impl types in `base.h`.
* base.h defines a namespace-scoped member `take_ownership_from_abi`. So when you include `base.h`, that gets defined & initialized.
  - You can't conditionally exclude that from `base.h` when building the module, beacuse it has to exist in the module for literally everything else in cppwinrt -> it has to be in the module.
  - You can't ifdef it out of `base.h` for the `include` of `base.h`, because base.h will have to preceed the winrt module.

<hr>

### Notes, 15-Dec-2021

So Scott's managed to change the WinRT projection a decent amount to be able to get the base.h including sorted out.

But now I'm trying to export my `SimpleCustomComponent::Class` in the `SimpleCustomComponent` module. I've done:

```c++
export module SimpleCustomComponent;

import winrt;

#define WINRT_EXPORT export

#include "winrt/SimpleCustomComponent.h"
```

But now I'm getting the compiler error:
```
3>main.obj : error LNK2019: unresolved external symbol "public: __cdecl winrt::SimpleCustomComponent::Class::Class(void)" (??0Class@SimpleCustomComponent@winrt@@QEAA@XZ) referenced in function main
```
when trying to compile the exe that references that component. I've added a reference to the module like so:

```xml
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalModuleDependencies Condition="'$(Platform)'=='Win32'">$(SolutionDir)03-SimpleCustomComponent\mod\$(Configuration)\SimpleCustomComponent.ixx.ifc;%(AdditionalModuleDependencies)</AdditionalModuleDependencies>

      <AdditionalModuleDependencies Condition="'$(Platform)'!='Win32'">$(SolutionDir)03-SimpleCustomComponent\mod\$(Platform)\$(Configuration)\SimpleCustomComponent.ixx.ifc;%(AdditionalModuleDependencies)</AdditionalModuleDependencies>
    </ClCompile>
```

and `Class::Class` is defined in the module in `SimpleCustomComponent.2.h`:

```c++
WINRT_EXPORT namespace winrt::SimpleCustomComponent
{
    struct __declspec(empty_bases) Class : winrt::SimpleCustomComponent::IClass
    {
        Class(std::nullptr_t) noexcept {}
        Class(void* ptr, take_ownership_from_abi_t) noexcept : winrt::SimpleCustomComponent::IClass(ptr, take_ownership_from_abi) {}
        Class();
    };
}
```




## tl;dr, 10-Dec-2021

If you're authoring winrt types using cppwinrt, you're going to get a `module.g.cpp`, a `Class.g.h`, and a `MyComponent.h` all auto-generated for you by cppwinrt. These files all require some `winrt::impl` types that are defined in `winrt/base.h`, but are notably _not_ exported by the module. (They're implementation details of winrt, so that makes logical sense). That means these files are going to _need_ to `#include <winrt/base.h>`, to have access to those internal types.

However, `base.h` also defines some things that make using it both as a module `import` and as an `#include` not work. Notably:
* the `WindowsNumerics.impl.h` header, which results in a bunch of redefinitions of types. This can be ifdef'd out of base.h easily enough, so modifing cppwinrt to fix this shouldn't be too hard.
* There's also the `winrt::take_ownership_from_abi` member, which is a static(?) global in the `winrt` namespace.
  - It needs to be exported from the module, because it needs to be usable when the module is imported _without_ including `base.h`
  - but for components that _need_ to include `base.h`, they need to include that header before the module, so the definition in the module will _always_ conflict with the one already in the header. It can't be removed from that header either, because that header relies on it heavily.
